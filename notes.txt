App1 => A common task we might perform with a model like this is to update an article's status from "draft"to
"published". We could easily do this in the admin one article at a time, but if we wanted to bulk-publish
a group of articles, it'd be tedious. So, let's write an action that lets us change an article's status to
"published."

=> Writing action functions
First, we'll need to write a function that gets called when the action is triggered from the admin. Action
functions are regular functions that take three arguments:

    • The current ModelAdmin => The ModelAdmin class is the representation of a model in the admin interface.Usually, these are stored.in a file named admin.py in your application
    • An HttpRequest representing the current request,
    • A QuerySet containing the set of objects selected by the user.
Our publish-these-articles function won't need the ModelAdmin or the request object, but we will use the



queryset:
def make_published(modeladmin, request, queryset):
    queryset.update(status='p')

Note: For the best performance, we're using the queryset's update method. Other types of actions might
need to deal with each object individually; in these cases we􀁮d iterate over the queryset:
for obj in queryset:
    do_something_with(obj)  


ngettext() takes three arguments: the singular translation string, the plural translation string and the number of objects


def get_actions():
 => now we can give actions as per user or may be user role like that

 action method can be as per user and restricts but if we give them permission then action method can be changebale 
 Ex:
 if i give a user he can only change status of a article to published only but if give change permission to him he can then also change the status by view the details.


model-admin=>The ModelAdmin class is the representation of a model in the admin interface. Usually, these are stored
in a file named admin.py in your application
In the preceding example, the ModelAdmin class doesn􀁮t define any custom values (yet). As a result,
the default admin interface will be provided. If you are happy with the default admin interface, you
don􀁮t need to define a ModelAdmin object at all 􂚶you can register the model class without providing a
ModelAdmin description





app2=>
we can create our own filter by inheriting simplelistfilter

automatic django admin document generator 
python3 -m pip install docutils  

documents are generated by docstring 

how to render a dynamic fields from models.py to admin.py

adding some admin features:=>
    list_display_links = ('name',)
    list_editable = ('email',)
    list_filter = (EmailFilter, dobFilter)
    list_per_page = 2




fields vs list-display

fields that accepts the field while we insert from admin 
list display is for display the 


app3=>

ordering
search field

list_select_releted = 
When value is True, select_related() will always be called. When value is set to False, Django will
look at list_display and call select_related() if any ForeignKey is present.

prepopulated_fields = {"slug": ("cat_name",)} = automatically created slug field data as per cat_name 


search_fields = ['foreign_key__related_fieldname']
For example, if you have a blog entry with an author, the following definition would enable searching
blog entries by the email address of the author:  using the icontains lookup

I.e we can override get_search_results(self,request, search_term)

We can ovverride model methods also as per requirements Ex: can be override search fields see django docs 1008



Inline methods
class InlineModelAdmin=>
class TabularInline
class StackedInline


